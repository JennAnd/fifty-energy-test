<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sensors</title>
    <link rel="stylesheet" href="./css/index.css" />
    <link rel="stylesheet" href="./css/sensors.css" />
  </head>
  <body>
    <!------- Create new sensors and view sensors ------->
    <div class="container">
      <header>
        <h1>Sensors</h1>
        <p><a href="login.html">Log out</a></p>
      </header>
      <!-- Search sensors by name or type -->
      <form id="searchForm" class="sensor-form">
        <input id="q" placeholder="Search by name or type" />
        <button type="submit">Search</button>
        <span
          id="loading"
          class="spinner"
          hidden
          aria-live="polite"
          title="Loading"
        ></span>
      </form>

      <!-- Create a new sensor form -->
      <form id="createForm" class="sensor-form">
        <input id="name" placeholder="Name" required />
        <input id="type" placeholder="Type" required />
        <button type="submit">Add sensor</button>
      </form>

      <hr />

      <!-- List of all sensors for this user-->
      <ul id="list"></ul>

      <!-- Pagination control (prev page and next page)-->
      <div id="pager" hidden>
        <button id="prevBtn">Prev</button>
        <span id="pageInfo"></span>
        <button id="nextBtn">Next</button>
      </div>
    </div>

    <script>
      // Get saved token or redirect if not logged in
      function getToken() {
        const t = localStorage.getItem("token");
        if (!t) {
          alert("You must log in first.");
          location.href = "login.html";
          throw new Error("No token found");
        }
        return t;
      }

      // Keeps current search text and active page so we can rebuild the query string
      let searchState = { q: "", page: 1 };
      // Build the search part of the URL, example: ?q=temperature
      function buildQS() {
        const p = new URLSearchParams();
        if (searchState.q) p.set("q", searchState.q.trim()); // If user typed something, add it
        if (searchState.page > 1) p.set("page", String(searchState.page));

        // If something was added return it with ?, otherwise return nothing
        return p.toString() ? "?" + p.toString() : "";
      }

      // Load all sensors that belong to the logged-in user
      async function loadSensors() {
        const token = getToken();
        const loader = document.getElementById("loading");
        // Show loader while fetching
        loader.hidden = false; // show
        try {
          // GET /api/sensors (requires Bearer token)
          const res = await fetch(
            "http://localhost:8000/api/sensors" + buildQS(),
            {
              headers: { Authorization: "Bearer " + token },
            }
          );

          // Handle invalid token
          if (res.status === 401) {
            alert("Session expired. Please log in again.");
            localStorage.removeItem("token");
            location.href = "login.html";
            return;
          }

          // Handle other errors
          if (!res.ok) throw new Error("Failed to load sensors");

          // Parse JSON response
          const data = await res.json();

          // Support both array and paginated formats
          const items = Array.isArray(data) ? data : data.items || [];

          // Show sensors in a list
          const ul = document.getElementById("list");
          ul.innerHTML = "";

          // If no sensors are found, show a message
          if (items.length === 0) {
            ul.innerHTML = "<li>No sensors found.</li>";
          } else {
            // Loop through each sensor from the API response
            items.forEach((s) => {
              const li = document.createElement("li");

              // Each sensor shows name, type and two buttons (Edit / Delete)
              li.innerHTML = `
  <span class="name"><a href="sensor.html?id=${s.id}">${s.name}</a></span>
  <span class="sep" aria-hidden="true"></span>
  <span class="type">${s.model ?? s.type ?? ""}</span>
  <button onclick="editSensor(${s.id}, '${s.name.replace(/'/g, "\\'")}', '${(s.model ?? s.type ?? "").replace(/'/g, "\\'")}')">Edit</button>
  <button onclick="deleteSensor(${s.id})">Delete</button>
`;

              ul.appendChild(li);
            });
          }

          // Pagination
          const pager = document.getElementById("pager");
          const prevBtn = document.getElementById("prevBtn");
          const nextBtn = document.getElementById("nextBtn");
          const pageInfo = document.getElementById("pageInfo");

          if (Array.isArray(data)) {
            // Non-paginated response - hide pager
            pager.hidden = true;
          } else {
            const TOTAL = Number(data.count ?? 0);
            const PAGE_SIZE = 10;
            const page = Number(searchState.page || 1);
            const pages = Math.max(1, Math.ceil(TOTAL / PAGE_SIZE));

            // Show pager only if there is more than one page
            pager.hidden = pages <= 1;

            // Update text and button states
            pageInfo.textContent = `Page ${page} / ${pages}`;
            prevBtn.disabled = page <= 1;
            nextBtn.disabled = page >= pages;

            // Wire up the buttons to update state and reload
            prevBtn.onclick = () => {
              if (searchState.page > 1) {
                searchState.page -= 1;
                loadSensors().catch((err) => alert(err.message));
              }
            };
            nextBtn.onclick = () => {
              const max = pages || searchState.page + 1;
              if (searchState.page < max) {
                searchState.page += 1;
                loadSensors().catch((err) => alert(err.message));
              }
            };
          }
        } catch (err) {
          alert("Error: " + err.message);
        } finally {
          // Always hide loader when done (success or error)
          loader.hidden = true; // hide
        }
      }

      // Handle create sensor form
      document
        .getElementById("createForm")
        .addEventListener("submit", async (e) => {
          e.preventDefault();
          const token = getToken();

          // Get input values
          const name = document.getElementById("name").value.trim();
          const type = document.getElementById("type").value.trim();
          if (!name || !type) return;

          try {
            // POST /api/sensors with JSON body
            const res = await fetch("http://localhost:8000/api/sensors", {
              method: "POST",
              headers: {
                Authorization: "Bearer " + token,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ name, type }),
            });

            // Handle invalid token
            if (res.status === 401) {
              alert("Session expired. Please log in again.");
              localStorage.removeItem("token");
              location.href = "login.html";
              return;
            }

            // Handle other errors
            if (!res.ok) {
              const text = await res.text();
              throw new Error(text || "Failed to create sensor");
            }

            // If success, reload list and clear input fields
            await loadSensors();
            document.getElementById("name").value = "";
            document.getElementById("type").value = "";
          } catch (err) {
            alert("Error: " + err.message);
          }
        });

      // Edit a sensor (PUT), use PUT when update or replace an existing item in the database
      async function editSensor(id, curName, curType) {
        const token = getToken(); // Get the saved login token

        // Ask user for new name and type
        const newName = prompt("New sensor name:", curName);
        if (newName === null) return;
        const newType = prompt("New sensor type/model:", curType);
        if (newType === null) return;

        // Send PUT request to update sensor data
        const res = await fetch(`http://localhost:8000/api/sensors/${id}`, {
          method: "PUT",
          headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ name: newName.trim(), type: newType.trim() }),
        });

        // If token expired, log user out
        if (res.status === 401) {
          alert("Session expired. Please log in again.");
          localStorage.removeItem("token");
          location.href = "login.html";
          return;
        }

        // If update fail, show message
        if (!res.ok) {
          const text = await res.text();
          alert("Failed to update: " + (text || res.status));
          return;
        }
        loadSensors(); // reload list
      }

      // Delete a sensor (DELETE)
      async function deleteSensor(id) {
        const token = getToken();

        // Ask user to confirm before deleting
        if (!confirm("Delete this sensor (and its readings)?")) return;

        // Send DELETE request to backend
        const res = await fetch(`http://localhost:8000/api/sensors/${id}`, {
          method: "DELETE",
          headers: { Authorization: "Bearer " + token },
        });

        // Handle expired or invalid token
        if (res.status === 401) {
          alert("Session expired. Please log in again.");
          localStorage.removeItem("token");
          location.href = "login.html";
          return;
        }

        // If delete fails, show message
        if (res.status !== 204) {
          const text = await res.text();
          alert("Failed to delete: " + (text || res.status));
          return;
        }

        if (searchState.page > 1) searchState.page -= 1;
        loadSensors(); // reload list
      }

      // When user clicks Search
      document.getElementById("searchForm").addEventListener("submit", (e) => {
        e.preventDefault(); // Stop page from reloading
        searchState.q = document.getElementById("q").value;
        searchState.page = 1; // reset page on new search

        loadSensors().catch((err) => alert(err.message));
      });

      // Load sensors automatically when the page opens
      loadSensors();
    </script>
  </body>
</html>
